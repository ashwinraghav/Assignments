(***************************************************************************)
(*                                                                         *)
(*     Standard Interface Library  - Application Framework Services        *)
(*                                                                         *)
(* This is a demonstration of how to support event dispatching between     *)
(*  objects of different kinds.                                            *)
(*                                                                         *)
(* This is a standard mechanism used by all the library in its different   *)
(*  layers.                                                                *)
(*                                                                         *)
(***************************************************************************)

unit FmTestBaseFrameworkEvents;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls,

  Sil;

type
  // Interface that we use to simulate the firing of an asynchronous event
  IDispatcher = interface
    ['{3984CA83-0156-42AE-8CD8-B8A7DE61FC0D}']
    procedure DoDispatch(const Text: string; Timestamp: TDateTime);
  end;

  // This record represent the arguments that we want to pass in the event
  REvent = record
    Sender: IUnknown;
    Text: string;
    Timestamp: TDateTime;
  end;

  // This interface represents the events we want to receive.
  //  We must implement it and connect to the event source which
  //  in turn when an event occurs it will be calling us using this
  //  interface as a callback.
  // Normally, every object that fires events defines a interface or
  //  several of them, to represent it event firing capabilities.
  //  So, the definition of the events fired is part of an object
  //  interface specification. 
  IDispatcherEvents = interface
    ['{3FEA3980-6953-4DB7-A0B9-02877F353472}']
    procedure OnDispatch(var Event: REvent);
  end;

  // Simulation of an object that fires events. In this case we're simply going to
  //  fire an event in response to a button click. But, there are more interesting
  //  cases out there ... :)  
  TDispatcher = class (
    // extends
    TSilInterfacedObject, // this is our object thats support event firing primitives natively
    // implements
    IDispatcher           // we add this to have a entry point to the outer world!!
    )
  protected // IDispatcher
    // simulate the firing of the event
    procedure DoDispatch(const Text: string; Timestamp: TDateTime);
  end;

  // That's us ...
  //  Thus, we're implementing the sink interface to state
  //  that we want to receive the events from the ouside
  //  world.
  TFormTestEvents = class(
    TForm,
    IUnknown,         // it is safer this way ....
    IDispatcherEvents // this is the sink interface
    )
    btDispatchEvent: TButton;
    Memo: TMemo;
    edText: TEdit;
    procedure btDispatchEventClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
  private
    // we hold the dispatcher here to control its life time.
    FDispatcher: IDispatcher;
  protected // IDispatcherEvents
    // here we are notified of events fired by the Dispatcher above.  
    procedure OnDispatch(var Event: REvent);
  end;

var
  FormTestEvents: TFormTestEvents;

implementation

{$R *.dfm}

procedure TFormTestEvents.FormCreate(Sender: TObject);
begin
  // create the Dispatcher object
  FDispatcher := TDispatcher.Create;
  // and connect to them. This is the standard way to
  //  trap the events generated by any object.
  // It doesn't even require that the object have any
  //  knowledge of us, rather the only requisite is
  //  that we have to implement the sink interface.
  // The parameters of Sil.Sink.Connect are as follows:
  //  Source: the object that fires tha events.
  //  Listener: the receiver of the events fired by the object.
  Sil.Sink.Connect(FDispatcher, Self);
end;

procedure TFormTestEvents.FormDestroy(Sender: TObject);
begin
  // Before our destruction proceeds, we must disconnect
  //  ourselves from the object.
  Sil.Sink.Disconnect(FDispatcher, Self);
  // Now, we release the dispatcher object.
  FDispatcher := nil;
end;

procedure TFormTestEvents.btDispatchEventClick(Sender: TObject);
begin
  // simulate an event
  FDispatcher.DoDispatch(edText.Text, Sil.DateTime.Now);
end;

procedure TFormTestEvents.OnDispatch(var Event: REvent);
begin
  // we received an event, so write a log of it.
  Memo.Lines.Add(Sil.Str.Format('OnDispatch: Text = %s; Timestamp = %s', [Event.Text, Sil.DateTime.ToStr(Event.Timestamp)]));
end;

{ TDispatcher }

//  This is the event firing loop.
//
//  This code is very similar in all the objects that fires events.
//
// First, it checks to see if the object has connection support.
// Then, if it is true, it iterates over the Events list and
//  for every object if it implements the desired interface
//  it calls a method of it according to which event is needed to fire.

procedure TDispatcher.DoDispatch(const Text: string; Timestamp: TDateTime);
var
	Enum: IEnumerator;
	Sink: IDispatcherEvents;
	Event: REvent;
begin
  if HasConnections then
  // True if Events is not nil
  begin
    // fill in the event info
    Event.Text := Text;
    Event.Timestamp := Timestamp;
    Event.Sender := Self;

    // Enumerate the Events list
    with Events do
      while Enumerate(Enum, Sink, IDispatcherEvents) do
        // only receives the objects that implements IDispatcherEvents
        Sink.OnDispatch(Event);
  end;
end;

end.
