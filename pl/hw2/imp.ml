(* Graduate Programming Languages - Wes Weimer
 *
 * Follows Glynn Winskel's _The Formal Semantics of Programming Languages_
 *
 * This is an abstract syntax for IMP. 
 *
 * Do not edit this file -- instead, edit hw2.ml and submit that as per the
 * directions in the homework. 
 *)

type n = int
type t = bool
type loc = string

type aexp =  (* Winskel page 12 *) 
  | Const of n                  (* n *)
  | Var of loc                  (* X *)
  | Add of aexp * aexp          (* a0 + a1 *) 
  | Sub of aexp * aexp          (* a0 - a1 *) 
  | Mul of aexp * aexp          (* a0 * a1 *) 

type bexp =
  | True
  | False
  | EQ of aexp * aexp           (* a0 == a1 *) 
  | LE of aexp * aexp           (* a0 <= a2 *) 
  | Not of bexp                 (* !b *)
  | And of bexp * bexp          (* b0 /\ b1 *) (* b0 && b1 *) 
  | Or of bexp * bexp           (* b0 \/ b1 *) (* b0 || b1 *) 

type com =
  | Skip
  | Set of loc * aexp           (* X := a *) 
  | Seq of com * com            (* c0 ; c1 *)
  | If of bexp * com * com      (* if b then c0 else c1 *)
  | While of bexp * com         (* while b do c *)

  | Print of aexp               (* print a *) 

  (* these special new commands are added for homework #2 *) 
  | Throw of aexp               (* throw e *) 
  | TryCatch of com * loc * com (* try c1 catch x c2 *)
  | AfterFinally of com * com   (* after c1 finally c2 *) 


(* Pretty-printing utility functions -- these aren't necessary but might be
 * handy for debugging. They convert instances of Aexp, Bexp and Com into
 * strings (that you can print out later with print_string, say). *) 
open Printf 

let rec aexp_to_str a = match a with
  | Const(n) -> string_of_int n
  | Var(l) -> l
  | Add(a,b) -> sprintf "(%s + %s)" (aexp_to_str a) (aexp_to_str b)
  | Sub(a,b) -> sprintf "(%s - %s)" (aexp_to_str a) (aexp_to_str b)
  | Mul(a,b) -> sprintf "(%s * %s)" (aexp_to_str a) (aexp_to_str b)

and bexp_to_str b = match b with
  | True ->     "true"
  | False ->    "false" 
  | EQ(a,b) ->  sprintf "(%s = %s)" (aexp_to_str a) (aexp_to_str b) 
  | LE(a,b) ->  sprintf "(%s <= %s)" (aexp_to_str a) (aexp_to_str b) 
  | Not(b) ->   sprintf "!%s" (bexp_to_str b) 
  | And(a,b) -> sprintf "(%s && %s)" (bexp_to_str a) (bexp_to_str b)
  | Or(a,b) ->  sprintf "(%s || %s)" (bexp_to_str a) (bexp_to_str b)

and com_to_str c = match c with
  | Skip ->        "skip"
  | Set(l,a) ->    sprintf "%s := %s" l (aexp_to_str a)
  | Seq(a,b) ->    sprintf "%s ;\n%s" (com_to_str a) (com_to_str b)
  | If(b,c0,c1) -> sprintf "if %s then { %s } else { %s }" 
                      (bexp_to_str b) (com_to_str c0) (com_to_str c1) 
  | While(b,c)  -> sprintf "while %s do { %s }" 
                      (bexp_to_str b) (com_to_str c) 
  | Throw(a)    -> sprintf "throw %s" (aexp_to_str a) 
  | TryCatch(c1,x,c2) -> sprintf "try { %s } catch %s { %s }" 
                    (com_to_str c1) x (com_to_str c2) 
  | AfterFinally(c1,c2) -> sprintf "after { %s } finally { %s }"
                    (com_to_str c1) (com_to_str c2) 
  | Print(a)    -> sprintf "print %s" (aexp_to_str a)
