The need to abstract data and functionality is the most important reason the Object Oriented Programming paradigm exists. One of the most effective ways to judge a programming language is to audit the design-patterns that are most commonly seen in it. The shape of a program must reflect only the problem that it intends solving. Any regularity in the code can often mean that the language being used is not powerful enough to provide the right kind of abstractions. In that sense older and commonly used abstraction patterns like the iterator have become features in almost all languages.

Data and behavioural abstractions are useful to simplify connections between entities and to encapsulate decisions that are likely to change. The gamut of constructs in different programming languages are manifestations of the DRY (do not repeat yourself) philosophy preached by behavioural abstraction. It is easy to see that the philosophy has dominated the programming language world in the past 2 decades. However ,it can be shown that some of the most common problems that are faced by software systems are consequences of over-simplifications made by the OO paradigm. For example, Inheritance requires a lot of discipline in practice. Often, the decision to inherit one abstract data-type from another results in a highly bound/restrained situation when the code is being refactored to incorporate changing requirements. Programmers tend to view inheritance as just a hierarchical way to abstract out behaviour and in the process forget to ask themselves the “is a?” question. There are several essays that propose ‘composition’ design-pattern as a more malleable alternative to inheritance. 

Also, traditional data abstraction in OO makes no recommendations about how computer programs should handle mutability over time. Mathematical abstractions in a computer program can be an over-simplification since they have no notion of time. Programmatic abstractions on the other hand are time dependent. Be it in terms of consumption of memory or clock cycles, all (useful) programs have observable effects over time. And the composite way in which traditional Abstract Data Types are built is not the right way to handle state in multi threaded programs.

In the concurrency era, an abstraction mechanism must make recommendations on how a language should differentiate between state, value and identity. Also, languages need to find efficient ways to realise these philosophies without compromising on the performance that traditional languages provided. Tools like immutable-data-structures help efficiently represent state as values and their identities and not as variable entities that change over time. An abstraction mechanism that will identify the purely functional part of a program and recommend constructs that will help using values in the part of a program dealing with state is what we wish to recommend.

P.S Pardon the plagiarised conclusion.