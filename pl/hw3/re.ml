(* Wes Weimer - Graduate Programming Languages
 *
 * This is an abstract syntax for regular expressions. 
 *
 * Do not edit this file -- instead, edit hw3.ml and submit that as per the
 * directions in the homework. 
 *)

(* we formally model a string as a list of characters *) 
type re_string = char list 

(* The 'decompose' function returns None if its argument is the empty
 * string and Some(x,y) where x is the first character in the string and
 * y is the rest of the string. You can also pattern-match on re_strings
 * directly if you like. *) 
let decompose (rs : re_string) = match rs with
  | [] -> None
  | hd :: tl -> Some(hd,tl) 

(* the possible types of regular expressions *) 
type re = 
  | Char of char              (* 'x' *)
  | AnyChar                   (* . *) 
  | Empty                     (* empty *) 
  | CharRange of char * char  (* ['a'-'z'] *) 
  | Concat of re * re         (* r1 r2 *) 
  | Or of re * re             (* r1 | r2 *) 
  | Star of re                (* re* *)
  | Plus of re                (* re+ *) 
  | Question of re            (* re? *) 
(* Notes: 
 *
 * The user may enter quoted strings like "xy" -- the parser will translate
 * them into things like Concat(Char('x'),Char('y')) automatically. 
 * 
 * For CharRange(x,y) you are guaranteed that x <= y. 
 *
 * For Char(x) and CharRange(x,y) you may assume that the characters are
 * 7-bit clean "obvious ASCII" characters -- this is not a test of your
 * Unicode UTF/8 internationalization abilities, this is a test of
 * semantics. This should not matter, though -- <= works on char in Ocaml. 
 *)

(*
 * We will use OCaml's standard library Set to keep track of sets of
 * re_strings. These sets are purely applicative (no side effects). The
 * standard library will use balanced binary trees to implement the set, so
 * we need to tell it how to order the elements. You do not need to
 * understand this "module" bit to do the assignment. 
 *
 * ML uses "functors" to build new modules. This is somewhat like the C++
 * template system. Want to learn something new about PL? Check it out: 
 *
 * http://en.wikipedia.org/wiki/Function_object
 * http://en.wikipedia.org/wiki/Functor
 *)
module OrderedReString =
  struct
    type t = re_string
    let compare = compare
  end
module ReStringSet = Set.Make(OrderedReString)

type stringset = ReStringSet.t 

(* this returns an empty set of strings *) 
let emptyset = ReStringSet.empty 

let is_empty set = ReStringSet.is_empty set

let contains element set = ReStringSet.mem element set 

(* note: add returns a new, bigger set -- the old set is unchanged! *) 
let add element set = ReStringSet.add element set 

let singleton element = ReStringSet.singleton element 

let union set1 set2 = ReStringSet.union set1 set2 

(* applies 'callback' to every re_string in the set *) 
let iter callback set = ReStringSet.iter callback set 

let fold callback set initial = ReStringSet.fold callback set initial

(* this utility function converts a normal string to our "list" notation *) 
let string_to_re_string (s : string) =
  let result = ref [] in
  for i = pred (String.length s) downto 0 do
    result := s.[i] :: !result 
  done ;
  !result 

(* Pretty-printing utility functions -- these aren't necessary but might be
 * handy for debugging. *)
open Printf 

let rec re_string_to_str s = match s with
  | [] -> "" 
  | hd :: tl -> sprintf "%c%s" hd (re_string_to_str tl) 

let rec re_to_str re = match re with
  | Char(c)   -> sprintf "'%c'" c
  | AnyChar   -> "."
  | Empty     -> "empty" 
  | CharRange(x,y) -> sprintf "['%c'-'%c']" x y 
  | Concat(x,y)    -> sprintf "(%s %s)" (re_to_str x) (re_to_str y)
  | Or(x,y)        -> sprintf "(%s | %s)" (re_to_str x)
                        (re_to_str y)
  | Star(x)        -> sprintf "%s*" (re_to_str x) 
  | Plus(x)        -> sprintf "%s+" (re_to_str x) 
  | Question(x)    -> sprintf "%s?" (re_to_str x) 

